---
layout: post
published: true
title: The Ideal Work Term Progression for Computer Engineers, part I
---

With their Computer Engineering degrees now complete, my classmates (and I, in a sense) are now working at -- or
searching for -- their first permanent full-time jobs. Looking back on the journey that got us where we are, the one
thing that stands out between my classmates is the experience they got while on their co-op terms, and the quality of
their resulting full-time jobs. I thought I'd take this opportunity to share what I've learned about what co-op jobs you
should be looking for at each stage in the Waterloo co-op progression. This article is the first in a series of 6
(parts [I][I], [II][II], [III][III], [IV][IV], [V][V], [VI][VI]) on what you should be doing for each co-op work term
with the University of Waterloo in order to get jobs with the best companies in your last few co-op terms; this part
covers your first work term.

This series is written for computer engineering students in the University of Waterloo's cooperative education (co-op)
program, which consists of a series of 6 work terms in a repeating 4 months school/4 months work pattern for four years
of the student's five year degree. Most of the information presented here is not unique to UW students, however;
students in a more traditional university program can still apply these tips by ignoring the term specifications and
applying them in order to their work opportunities instead. Longer (8-, 12-, or 16-month) work terms also fit into this
model; aim to be done the same things as a 4-month UW co-op student would be at that level of work experience (for
example, a 16-month intern should try to complete items up to the 4th work term level by the end of their internship).

## Your First Work Term -- Getting a Job

#### Make an effort.

Students first applying for jobs after 2 weeks (4-stream) or 4 months and 2 weeks (8-stream) of university. As a result,
4 streamers only have their high school experience to go on, and 8 streamers have the same one programming course and
handful of science/math courses that their classmates do. In either case, experience is lacking, and one co-op student
looks pretty much like the next to an employer. What do you do? Make an effort when writing your resume and cover
letters, and when preparing for an interview. That means getting your resume critiqued, and acting on the feedback you
receive. It means spending time preparing for interviews, practicing with friends, and researching the companies you are
interviewing with (and who they sent out to interview you, if possible). And it means writing cover letters for the jobs
you are most qualified for (or want the most), and writing *personalized* cover letters from scratch for each company -
form cover letters just don't cut it. With all of the things that go on during the beginning of a term, it's easy to let
these things slide -- but in your first term, it's to your peril. Not getting a job can not only set you back
financially, but also makes finding jobs in the future that much more difficult. By making an effort, you'll set
yourself apart -- even if only by a little bit -- from your classmates. And in first year, that extra effort may be the
difference between getting a job and not.

#### Apply, Apply, Apply.

Every hiring manager is different, and looks for different things in a co-op student: experience, grades,
extra-curricular activities, hobbies, hometown, you name it. Without the one thing that carries other co-op students -
experience -- first year students get hired on everything else. And since you cannot determine beforehand what it is a
manger is looking for, the only rational solution is to play the odds and apply to a large quantity of jobs. You'll want
to make the most of your application limit -- don't throw away applications on positions you have no chance at getting
(primarily, those marked 'Senior'), and positions with fewer applications are more likely to grant you an interview -
but make sure you use every application you have. You can be picky about which jobs you take after you've been offered
them -- but that means you need to both get an interview (only a small percentage of your applications will turn into
interviews) as well as be the best candidate (your odds are better, since you'll only be fighting a handful of students
for each position, but it's far from certain). One exception to this rule: *never apply to a job you don't ever want to
do*. You'll always have some jobs that are better than other jobs, and that's OK; on ranking day, you can make the
selections that get you the best job from the ones you are offered. But applying for a job you wouldn't want to have is
never a good strategy; if they're the only company to offer you a job, then you could very well end up with it, and
spend four months in agony. You've been warned. The basic principle remains, though: more applications = more interviews =
more job offers, and the only one of those you can control directly is the number of applications (making an effort
improves the conversion rate between applications/interviews/offers).

#### Get any job you can.

Actually, this should read 'get any job you can that you enjoy doing'. In all likelihood, you're not going to be able to
pick your job area with any precision; in my first term, I applied for IT, software, and hardware jobs, and only got
interviews in IT and software -- and some of my classmates only got interviews in IT after applying to all 3. Unless
you've got prior experience in an area (with a particular programming language, software tool, etc.), limiting yourself
to narrowly focused fields (.NET, Java, Ruby, etc. development) will probably not result in enough positions to fill
your application count. And even if it does, you could be competing with older students that *do* have experience in one
of these areas, so applying exclusively to a single field is a pretty big risk (think of the 'eggs in one basket'
metaphor). It's impossible to know what a company is looking for and what other students have applied, so a diverse
application strategy is most likely to pay off.

#### Identify your dream job's field/industry vertical.

There are many potential career pathways leading from a degree in Computer Engineering (and other similar programs, like
Software Engineering and Computer Science) -- a short list is hardware/software development (and their many subdivisions,
including in-house and contracted development), IT work, and other jobs related to technology (tech policy/tech law,
etc.). The general rule is that the best jobs in those fields are found when the majority of your co-op experience
culminates in that job. So with a lot of hardware development experience, your chances of working for
Microsoft/Adobe/Amazon are limited, but are quite a bit better for positions at NVIDIA/AMD/Intel; the reverse holds if
you have a lot of software experience. If you know where you want to be in the end, then try to accept jobs that put you
in the right field. Without experience, some of these fields are hard to get into in your first term, and getting a job
is paramount -- don't focus your applications on a specific vertical yet; you can do that in future terms. But if you've
been offered a few different positions, consider leaning toward the jobs in the field you want to be in. Don't worry if
you don't have and idea where you want to end up yet -- most people develop that as they work their way through and get
more exposed to the industry, and you can change your goal as you progress.

#### If all else fails, improve your skills.

Sometime, your best efforts aren't enough to get you a job. Here's the secret: it's not going to get any easier the next
time through -- your classmates will have experience you don't have, which puts you in worse shape than you were in in
the first place. Even if you don't have a job, gaining experience is your number one priority. Learn a programming
language -- something used in industry (C#, Java, C/C++ are best, but Python or Ruby will do) -- well enough to build a
*useful* program ('Hello, World' doesn't count). Contribute to an open source project -- write documentation or find bugs
if you cannot code. Set up a network of computers and do something with them -- run a DNS server, configure a web farm,
do distributed compiles. Take classes at your local college. Start a business. Fix up your resume, and practice
interviewing. Anything is better than sitting around doing nothing for a term, but *relevant* experience is what you're
really looking for. Just because it's not for pay doesn't make it any less useful on a resume -- and you can potentially
do better than some of your colleagues who chose co-op jobs unwisely.

[I]: {% post_url 2009-08-14-the-ideal-work-term-progression-for-computer-engineers-part-i %}
[II]: {% post_url 2009-08-17-the-ideal-work-term-progression-for-computer-engineers-part-ii %}
[III]: {% post_url 2009-08-20-the-ideal-work-term-progression-for-computer-engineers-part-iii %}
[IV]: {% post_url 2009-08-23-the-ideal-work-term-progression-for-computer-engineers-part-iv %}
[V]: {% post_url 2009-08-27-the-ideal-work-term-progression-for-computer-engineers-part-v %}
[VI]: {% post_url 2009-09-01-the-ideal-work-term-progression-for-computer-engineers-part-vi %}
